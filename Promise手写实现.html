<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>test</title>
  </head>
  <body>
  </body>
  <script>
    let cnt = 1;
    // Promise基础版（实现了then链式调用+保存状态）
    class MyPromise{
      constructor(fn){
        this.name = `Promise-${cnt++}`;
        console.log('[%s]:constructor', this.name);
        this.callbacks = [];
        this.state = 'pending'; // 增加状态
        this.value =  null; // 保存结果
        fn(this.resolve.bind(this))
      }

      then(onFulFilled){
        console.log('[%s]:then', this.name);
        // 返回一个新的Promise对象！
        return new MyPromise((resolve) => {
          this.handle({
            onFulFilled: onFulFilled || null,
            resolve: resolve
          })
        })
      }

      handle(callback){
        console.log('[%s]:_handle', this.name, 'state=', this.state);
        // 异步操作尚未执行完毕
        if(this.state === 'pending'){
          console.log('[%s]:_handle', this.name, 'callbacks=', this.callbacks);
          this.callbacks.push(callback);
          return;
        }
        // then的参数为null(即没有给它传入回调)
        if(!callback.onFulFilled){
          // 直接将本Promise实例的值传给下一个promise
          callback.resolve(this.value);
          return;
        }
        // 异步操作已经成功，直接执行回调函数
        let res = callback.onFulFilled(this.value);
        callback.resolve(res);
      }

      resolve(value){
        console.log('[%s]:_resolve', this.name, 'value=', value);
        this.state = 'fulfilled'; // 改变状态
        this.value = value; // 保存结果
        this.callbacks.forEach(callback => this.handle(callback));
      }
    }


    // 测试
    // debugger
    // const mockAjax = (url, t, callback) => {
    //   setTimeout(() => {
    //     callback(url + '异步请求耗时' + t + '秒');
    //   }, 1000 * t)
    // }

    new MyPromise( resolve => {
      setTimeout(() => {
        resolve('异步操作耗时3秒')
      }, 3000)
    }).then(res => {
      console.log(res)
    })

    // Promise.all手写实现，
    MyPromise.all = function(promises){
      return new MyPromise((resolve, reject) => {
        const results = [];
        let count = 0;
        promises.forEach((promise, index) => {
          promise.then((res) => {
            results[index] = res;
            if(++count == promises.length){
              resolve(results);
            }
          }, (err) => reject(err))
        })
      })
    }

  </script>
</html>